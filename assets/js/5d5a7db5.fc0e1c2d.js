"use strict";(self.webpackChunkroadmap=self.webpackChunkroadmap||[]).push([[7704],{5382:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"02-api-design","title":"API Design & Development","description":"The Application Programming Interface (API) is the backbone of modern software. For a senior backend engineer, mastering API design is not just about exposing data; it\'s about creating a clear, consistent, and secure contract that empowers consumers of your service.","source":"@site/docs/02-api-design.mdx","sourceDirName":".","slug":"/api-design","permalink":"/roadmap/docs/api-design","draft":false,"unlisted":false,"editUrl":"https://github.com/alishahidi/roadmap/tree/main/docs/02-api-design.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"02-api-design","slug":"/api-design","sidebar_position":2,"title":"API Design & Development"},"sidebar":"roadmapSidebar","previous":{"title":"Foundations of Backend Engineering","permalink":"/roadmap/docs/foundations"},"next":{"title":"System Architecture & Design","permalink":"/roadmap/docs/system-architecture"}}');var t=s(4848),a=s(8453);const i={id:"02-api-design",slug:"/api-design",sidebar_position:2,title:"API Design & Development"},o=void 0,l={},c=[{value:"REST APIs",id:"rest-apis",level:2},{value:"Resource-Based Design Examples",id:"resource-based-design-examples",level:3},{value:"Complete REST API Implementation Examples",id:"complete-rest-api-implementation-examples",level:3},{value:"HTTP Status Codes in Practice",id:"http-status-codes-in-practice",level:3},{value:"GraphQL",id:"graphql",level:2},{value:"gRPC (Google Remote Procedure Call)",id:"grpc-google-remote-procedure-call",level:2},{value:"Protocol Buffers Definition",id:"protocol-buffers-definition",level:3},{value:"gRPC Server Implementation Examples",id:"grpc-server-implementation-examples",level:3},{value:"gRPC vs REST vs GraphQL Comparison",id:"grpc-vs-rest-vs-graphql-comparison",level:3},{value:"When to Use gRPC",id:"when-to-use-grpc",level:3},{value:"GraphQL Schema and Resolvers Examples",id:"graphql-schema-and-resolvers-examples",level:3},{value:"Solving the N+1 Problem",id:"solving-the-n1-problem",level:3},{value:"API Security Best Practices",id:"api-security-best-practices",level:2},{value:"Authentication &amp; Authorization",id:"authentication--authorization",level:3},{value:"JWT Implementation Examples",id:"jwt-implementation-examples",level:3},{value:"Testing Strategies for APIs",id:"testing-strategies-for-apis",level:2},{value:"Testing Pyramid",id:"testing-pyramid",level:3},{value:"Types of API Testing",id:"types-of-api-testing",level:3},{value:"Testing Best Practices",id:"testing-best-practices",level:3},{value:"Comprehensive API Testing Examples",id:"comprehensive-api-testing-examples",level:3},{value:"API Documentation &amp; Testing Tools",id:"api-documentation--testing-tools",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The Application Programming Interface (API) is the backbone of modern software. For a senior backend engineer, mastering API design is not just about exposing data; it's about creating a clear, consistent, and secure contract that empowers consumers of your service."}),"\n",(0,t.jsx)(n.h2,{id:"rest-apis",children:"REST APIs"}),"\n",(0,t.jsx)(n.p,{children:"REST (Representational State Transfer) has been the dominant architectural style for web APIs for years because it's built on the same principles as the web itself: simplicity, scalability, and statelessness."}),"\n",(0,t.jsx)(n.h3,{id:"resource-based-design-examples",children:"Resource-Based Design Examples"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Good REST API Design:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-http",children:"# Users Resource\nGET    /api/v1/users              # Get all users\nGET    /api/v1/users/123          # Get specific user\nPOST   /api/v1/users              # Create new user\nPUT    /api/v1/users/123          # Replace entire user\nPATCH  /api/v1/users/123          # Partially update user\nDELETE /api/v1/users/123          # Delete user\n\n# Nested Resources\nGET    /api/v1/users/123/orders   # Get all orders for user 123\nPOST   /api/v1/users/123/orders   # Create order for user 123\nGET    /api/v1/users/123/orders/456 # Get specific order for user\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Bad REST API Design:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-http",children:"# \u274c RPC-style endpoints (avoid these)\nGET /getUser?id=123\nPOST /createUser\nPOST /updateUserPassword\nPOST /deleteUser\nGET /getUserOrders?userId=123\n"})}),"\n",(0,t.jsx)(n.h3,{id:"complete-rest-api-implementation-examples",children:"Complete REST API Implementation Examples"}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Node.js/Express Example:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const express = require('express');\nconst app = express();\n\n// User Resource Controller\nclass UserController {\n    // GET /api/v1/users\n    static async getAllUsers(req, res) {\n        try {\n            const { page = 1, limit = 10, search } = req.query;\n            const users = await userService.getUsers({ page, limit, search });\n            \n            res.status(200).json({\n                data: users.items,\n                pagination: {\n                    page: parseInt(page),\n                    limit: parseInt(limit),\n                    total: users.total,\n                    pages: Math.ceil(users.total / limit)\n                },\n                links: {\n                    self: `/api/v1/users?page=${page}&limit=${limit}`,\n                    next: page < Math.ceil(users.total / limit) \n                        ? `/api/v1/users?page=${parseInt(page) + 1}&limit=${limit}` \n                        : null\n                }\n            });\n        } catch (error) {\n            res.status(500).json({ error: 'Internal server error' });\n        }\n    }\n    \n    // POST /api/v1/users\n    static async createUser(req, res) {\n        try {\n            const { name, email, password } = req.body;\n            \n            // Validation\n            if (!name || !email || !password) {\n                return res.status(400).json({\n                    error: 'Validation failed',\n                    details: {\n                        name: !name ? 'Name is required' : null,\n                        email: !email ? 'Email is required' : null,\n                        password: !password ? 'Password is required' : null\n                    }\n                });\n            }\n            \n            const user = await userService.createUser({ name, email, password });\n            \n            res.status(201).json({\n                data: user,\n                links: {\n                    self: `/api/v1/users/${user.id}`,\n                    orders: `/api/v1/users/${user.id}/orders`\n                }\n            });\n        } catch (error) {\n            if (error.code === 'DUPLICATE_EMAIL') {\n                return res.status(409).json({ error: 'Email already exists' });\n            }\n            res.status(500).json({ error: 'Internal server error' });\n        }\n    }\n    \n    // PATCH /api/v1/users/:id\n    static async updateUser(req, res) {\n        try {\n            const { id } = req.params;\n            const updates = req.body;\n            \n            const user = await userService.updateUser(id, updates);\n            if (!user) {\n                return res.status(404).json({ error: 'User not found' });\n            }\n            \n            res.status(200).json({ data: user });\n        } catch (error) {\n            res.status(500).json({ error: 'Internal server error' });\n        }\n    }\n}\n\n// Routes\napp.get('/api/v1/users', UserController.getAllUsers);\napp.post('/api/v1/users', UserController.createUser);\napp.patch('/api/v1/users/:id', UserController.updateUser);\n"})})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Java Spring Boot Example"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api/v1/users")\n@Validated\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    @GetMapping\n    public ResponseEntity<PagedResponse<UserDto>> getAllUsers(\n            @RequestParam(defaultValue = "1") int page,\n            @RequestParam(defaultValue = "10") int limit,\n            @RequestParam(required = false) String search) {\n        \n        Page<User> users = userService.getUsers(page - 1, limit, search);\n        \n        PagedResponse<UserDto> response = new PagedResponse<>();\n        response.setData(users.getContent().stream()\n            .map(UserDto::fromEntity)\n            .collect(Collectors.toList()));\n        response.setPagination(new PaginationInfo(\n            page, limit, users.getTotalElements(), users.getTotalPages()\n        ));\n        \n        return ResponseEntity.ok(response);\n    }\n    \n    @PostMapping\n    public ResponseEntity<ApiResponse<UserDto>> createUser(\n            @Valid @RequestBody CreateUserRequest request) {\n        \n        User user = userService.createUser(request);\n        UserDto userDto = UserDto.fromEntity(user);\n        \n        ApiResponse<UserDto> response = new ApiResponse<>();\n        response.setData(userDto);\n        response.setLinks(Map.of(\n            "self", "/api/v1/users/" + user.getId(),\n            "orders", "/api/v1/users/" + user.getId() + "/orders"\n        ));\n        \n        return ResponseEntity.status(HttpStatus.CREATED).body(response);\n    }\n    \n    @PatchMapping("/{id}")\n    public ResponseEntity<ApiResponse<UserDto>> updateUser(\n            @PathVariable Long id,\n            @RequestBody UpdateUserRequest request) {\n        \n        Optional<User> userOpt = userService.updateUser(id, request);\n        if (userOpt.isEmpty()) {\n            return ResponseEntity.notFound().build();\n        }\n        \n        ApiResponse<UserDto> response = new ApiResponse<>();\n        response.setData(UserDto.fromEntity(userOpt.get()));\n        \n        return ResponseEntity.ok(response);\n    }\n}\n'})})]}),"\n",(0,t.jsx)(n.h3,{id:"http-status-codes-in-practice",children:"HTTP Status Codes in Practice"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Comprehensive status code usage\nconst StatusCodes = {\n    // 2xx Success\n    OK: 200,                    // GET successful\n    CREATED: 201,               // POST successful\n    NO_CONTENT: 204,            // DELETE successful\n    \n    // 4xx Client Errors\n    BAD_REQUEST: 400,           // Invalid request data\n    UNAUTHORIZED: 401,          // Authentication required\n    FORBIDDEN: 403,             // Authenticated but not authorized\n    NOT_FOUND: 404,             // Resource doesn't exist\n    CONFLICT: 409,              // Resource already exists\n    UNPROCESSABLE_ENTITY: 422,  // Validation errors\n    \n    // 5xx Server Errors\n    INTERNAL_SERVER_ERROR: 500, // Generic server error\n    SERVICE_UNAVAILABLE: 503    // Temporary server issue\n};\n\n// Usage in error handling\napp.use((error, req, res, next) => {\n    if (error instanceof ValidationError) {\n        return res.status(StatusCodes.UNPROCESSABLE_ENTITY).json({\n            error: 'Validation failed',\n            details: error.details\n        });\n    }\n    \n    if (error instanceof NotFoundError) {\n        return res.status(StatusCodes.NOT_FOUND).json({\n            error: 'Resource not found'\n        });\n    }\n    \n    // Log the error for debugging\n    console.error('Unhandled error:', error);\n    \n    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({\n        error: 'Internal server error'\n    });\n});\n"})}),"\n",(0,t.jsx)(n.admonition,{title:"Deep Dive: Resources",type:"tip",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"Microsoft REST API Guidelines"})]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://www.freecodecamp.org/news/how-to-design-a-great-api-with-these-10-api-design-best-practices/",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"How to Design a Great API"})," (FreeCodeCamp)"]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://swagger.io/specification/",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"OpenAPI Specification"})]})}),"\n"]})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"graphql",children:"GraphQL"}),"\n",(0,t.jsx)(n.p,{children:"GraphQL is a query language for your API that gives clients the power to ask for exactly what they need and nothing more. It's a powerful alternative to REST, especially for applications with complex data requirements or diverse clients (e.g., web and mobile)."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"grpc-google-remote-procedure-call",children:"gRPC (Google Remote Procedure Call)"}),"\n",(0,t.jsx)(n.p,{children:"gRPC is a high-performance, open-source RPC framework that uses HTTP/2 and Protocol Buffers. It's ideal for internal microservice communication and high-throughput systems."}),"\n",(0,t.jsx)(n.h3,{id:"protocol-buffers-definition",children:"Protocol Buffers Definition"}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Protocol Buffers Definition"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'// user.proto\nsyntax = "proto3";\n\npackage user.v1;\n\noption go_package = "github.com/yourcompany/user-service/api/user/v1";\noption java_package = "com.yourcompany.user.v1";\noption csharp_namespace = "YourCompany.User.V1";\n\nimport "google/protobuf/timestamp.proto";\nimport "google/protobuf/empty.proto";\n\n// User service definition\nservice UserService {\n  // Creates a new user\n  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);\n  \n  // Gets a user by ID\n  rpc GetUser(GetUserRequest) returns (GetUserResponse);\n  \n  // Updates user information\n  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);\n  \n  // Deletes a user\n  rpc DeleteUser(DeleteUserRequest) returns (google.protobuf.Empty);\n  \n  // Lists users with pagination\n  rpc ListUsers(ListUsersRequest) returns (ListUsersResponse);\n  \n  // Server streaming: Get user events\n  rpc GetUserEvents(GetUserEventsRequest) returns (stream UserEvent);\n  \n  // Client streaming: Batch create users\n  rpc BatchCreateUsers(stream CreateUserRequest) returns (BatchCreateUsersResponse);\n  \n  // Bidirectional streaming: Real-time user updates\n  rpc StreamUserUpdates(stream UserUpdateRequest) returns (stream UserUpdateResponse);\n}\n\n// Message definitions\nmessage User {\n  string id = 1;\n  string email = 2;\n  string first_name = 3;\n  string last_name = 4;\n  UserStatus status = 5;\n  google.protobuf.Timestamp created_at = 6;\n  google.protobuf.Timestamp updated_at = 7;\n  Address address = 8;\n  repeated string roles = 9;\n}\n\nmessage Address {\n  string street = 1;\n  string city = 2;\n  string state = 3;\n  string zip_code = 4;\n  string country = 5;\n}\n\nenum UserStatus {\n  USER_STATUS_UNSPECIFIED = 0;\n  USER_STATUS_ACTIVE = 1;\n  USER_STATUS_INACTIVE = 2;\n  USER_STATUS_SUSPENDED = 3;\n}\n\n// Request/Response messages\nmessage CreateUserRequest {\n  string email = 1;\n  string first_name = 2;\n  string last_name = 3;\n  Address address = 4;\n}\n\nmessage CreateUserResponse {\n  User user = 1;\n  string message = 2;\n}\n\nmessage GetUserRequest {\n  string id = 1;\n}\n\nmessage GetUserResponse {\n  User user = 1;\n}\n\nmessage UpdateUserRequest {\n  string id = 1;\n  string email = 2;\n  string first_name = 3;\n  string last_name = 4;\n  Address address = 5;\n}\n\nmessage UpdateUserResponse {\n  User user = 1;\n}\n\nmessage DeleteUserRequest {\n  string id = 1;\n}\n\nmessage ListUsersRequest {\n  int32 page_size = 1;\n  string page_token = 2;\n  string filter = 3; // e.g., "status=ACTIVE"\n}\n\nmessage ListUsersResponse {\n  repeated User users = 1;\n  string next_page_token = 2;\n  int32 total_count = 3;\n}\n\nmessage UserEvent {\n  string event_id = 1;\n  string user_id = 2;\n  EventType event_type = 3;\n  google.protobuf.Timestamp timestamp = 4;\n  string data = 5; // JSON payload\n}\n\nenum EventType {\n  EVENT_TYPE_UNSPECIFIED = 0;\n  EVENT_TYPE_CREATED = 1;\n  EVENT_TYPE_UPDATED = 2;\n  EVENT_TYPE_DELETED = 3;\n  EVENT_TYPE_LOGIN = 4;\n  EVENT_TYPE_LOGOUT = 5;\n}\n\nmessage GetUserEventsRequest {\n  string user_id = 1;\n  google.protobuf.Timestamp since = 2;\n}\n\nmessage BatchCreateUsersResponse {\n  repeated CreateUserResponse results = 1;\n  int32 success_count = 2;\n  int32 failure_count = 3;\n}\n\nmessage UserUpdateRequest {\n  string user_id = 1;\n  string field_name = 2;\n  string field_value = 3;\n}\n\nmessage UserUpdateResponse {\n  string user_id = 1;\n  bool success = 2;\n  string error_message = 3;\n}\n'})})]}),"\n",(0,t.jsx)(n.h3,{id:"grpc-server-implementation-examples",children:"gRPC Server Implementation Examples"}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)("summary",{children:"Go Server Implementation"}),"\n",(0,t.jsx)(n.strong,{children:"Click to expand Go gRPC server code"})]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// server.go\npackage main\n\nimport (\n    "context"\n    "fmt"\n    "io"\n    "log"\n    "net"\n    "time"\n\n    "google.golang.org/grpc"\n    "google.golang.org/grpc/codes"\n    "google.golang.org/grpc/status"\n    "google.golang.org/protobuf/types/known/emptypb"\n    "google.golang.org/protobuf/types/known/timestamppb"\n\n    pb "github.com/yourcompany/user-service/api/user/v1"\n)\n\ntype userServiceServer struct {\n    pb.UnimplementedUserServiceServer\n    users map[string]*pb.User\n}\n\nfunc newUserServiceServer() *userServiceServer {\n    return &userServiceServer{\n        users: make(map[string]*pb.User),\n    }\n}\n\nfunc (s *userServiceServer) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) {\n    // Validation\n    if req.Email == "" {\n        return nil, status.Errorf(codes.InvalidArgument, "email is required")\n    }\n\n    // Check if user already exists\n    for _, user := range s.users {\n        if user.Email == req.Email {\n            return nil, status.Errorf(codes.AlreadyExists, "user with email %s already exists", req.Email)\n        }\n    }\n\n    // Create user\n    userID := fmt.Sprintf("user_%d", time.Now().Unix())\n    user := &pb.User{\n        Id:        userID,\n        Email:     req.Email,\n        FirstName: req.FirstName,\n        LastName:  req.LastName,\n        Status:    pb.UserStatus_USER_STATUS_ACTIVE,\n        CreatedAt: timestamppb.Now(),\n        UpdatedAt: timestamppb.Now(),\n        Address:   req.Address,\n        Roles:     []string{"user"},\n    }\n\n    s.users[userID] = user\n\n    log.Printf("Created user: %s (%s)", user.Id, user.Email)\n\n    return &pb.CreateUserResponse{\n        User:    user,\n        Message: "User created successfully",\n    }, nil\n}\n\nfunc (s *userServiceServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {\n    if req.Id == "" {\n        return nil, status.Errorf(codes.InvalidArgument, "user ID is required")\n    }\n\n    user, exists := s.users[req.Id]\n    if !exists {\n        return nil, status.Errorf(codes.NotFound, "user with ID %s not found", req.Id)\n    }\n\n    return &pb.GetUserResponse{\n        User: user,\n    }, nil\n}\n\nfunc (s *userServiceServer) ListUsers(ctx context.Context, req *pb.ListUsersRequest) (*pb.ListUsersResponse, error) {\n    pageSize := req.PageSize\n    if pageSize <= 0 || pageSize > 100 {\n        pageSize = 10 // Default page size\n    }\n\n    var users []*pb.User\n    for _, user := range s.users {\n        // Apply filter if provided\n        if req.Filter != "" {\n            // Simple filter implementation\n            if req.Filter == "status=ACTIVE" && user.Status != pb.UserStatus_USER_STATUS_ACTIVE {\n                continue\n            }\n        }\n        users = append(users, user)\n    }\n\n    // Simple pagination\n    start := 0\n    if req.PageToken != "" {\n        // Parse page token (simplified)\n        fmt.Sscanf(req.PageToken, "%d", &start)\n    }\n\n    end := start + int(pageSize)\n    if end > len(users) {\n        end = len(users)\n    }\n\n    var nextPageToken string\n    if end < len(users) {\n        nextPageToken = fmt.Sprintf("%d", end)\n    }\n\n    return &pb.ListUsersResponse{\n        Users:         users[start:end],\n        NextPageToken: nextPageToken,\n        TotalCount:    int32(len(users)),\n    }, nil\n}\n\n// Server streaming example\nfunc (s *userServiceServer) GetUserEvents(req *pb.GetUserEventsRequest, stream pb.UserService_GetUserEventsServer) error {\n    // Simulate streaming events\n    events := []*pb.UserEvent{\n        {\n            EventId:   "evt_1",\n            UserId:    req.UserId,\n            EventType: pb.EventType_EVENT_TYPE_CREATED,\n            Timestamp: timestamppb.Now(),\n            Data:      `{"action": "user_created"}`,\n        },\n        {\n            EventId:   "evt_2",\n            UserId:    req.UserId,\n            EventType: pb.EventType_EVENT_TYPE_LOGIN,\n            Timestamp: timestamppb.Now(),\n            Data:      `{"ip": "192.168.1.1", "user_agent": "Chrome"}`,\n        },\n    }\n\n    for _, event := range events {\n        if err := stream.Send(event); err != nil {\n            return err\n        }\n        time.Sleep(1 * time.Second) // Simulate real-time events\n    }\n\n    return nil\n}\n\n// Client streaming example\nfunc (s *userServiceServer) BatchCreateUsers(stream pb.UserService_BatchCreateUsersServer) error {\n    var results []*pb.CreateUserResponse\n    var successCount, failureCount int32\n\n    for {\n        req, err := stream.Recv()\n        if err == io.EOF {\n            // Client finished sending\n            return stream.SendAndClose(&pb.BatchCreateUsersResponse{\n                Results:      results,\n                SuccessCount: successCount,\n                FailureCount: failureCount,\n            })\n        }\n        if err != nil {\n            return err\n        }\n\n        // Process each user creation\n        resp, err := s.CreateUser(context.Background(), req)\n        if err != nil {\n            failureCount++\n            results = append(results, &pb.CreateUserResponse{\n                Message: err.Error(),\n            })\n        } else {\n            successCount++\n            results = append(results, resp)\n        }\n    }\n}\n\n// Bidirectional streaming example\nfunc (s *userServiceServer) StreamUserUpdates(stream pb.UserService_StreamUserUpdatesServer) error {\n    for {\n        req, err := stream.Recv()\n        if err == io.EOF {\n            return nil\n        }\n        if err != nil {\n            return err\n        }\n\n        // Process update\n        user, exists := s.users[req.UserId]\n        if !exists {\n            stream.Send(&pb.UserUpdateResponse{\n                UserId:       req.UserId,\n                Success:      false,\n                ErrorMessage: "User not found",\n            })\n            continue\n        }\n\n        // Update field (simplified)\n        switch req.FieldName {\n        case "first_name":\n            user.FirstName = req.FieldValue\n        case "last_name":\n            user.LastName = req.FieldValue\n        default:\n            stream.Send(&pb.UserUpdateResponse{\n                UserId:       req.UserId,\n                Success:      false,\n                ErrorMessage: "Invalid field name",\n            })\n            continue\n        }\n\n        user.UpdatedAt = timestamppb.Now()\n\n        stream.Send(&pb.UserUpdateResponse{\n            UserId:  req.UserId,\n            Success: true,\n        })\n    }\n}\n\nfunc main() {\n    lis, err := net.Listen("tcp", ":50051")\n    if err != nil {\n        log.Fatalf("Failed to listen: %v", err)\n    }\n\n    // Create gRPC server with interceptors\n    s := grpc.NewServer(\n        grpc.UnaryInterceptor(loggingInterceptor),\n        grpc.StreamInterceptor(streamLoggingInterceptor),\n    )\n\n    pb.RegisterUserServiceServer(s, newUserServiceServer())\n\n    log.Printf("gRPC server listening on :50051")\n    if err := s.Serve(lis); err != nil {\n        log.Fatalf("Failed to serve: %v", err)\n    }\n}\n\n// Interceptors for logging and middleware\nfunc loggingInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n    start := time.Now()\n    \n    log.Printf("gRPC call: %s started", info.FullMethod)\n    resp, err := handler(ctx, req)\n    \n    duration := time.Since(start)\n    if err != nil {\n        log.Printf("gRPC call: %s failed in %v: %v", info.FullMethod, duration, err)\n    } else {\n        log.Printf("gRPC call: %s completed in %v", info.FullMethod, duration)\n    }\n    \n    return resp, err\n}\n\nfunc streamLoggingInterceptor(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {\n    log.Printf("gRPC stream: %s started", info.FullMethod)\n    err := handler(srv, stream)\n    if err != nil {\n        log.Printf("gRPC stream: %s failed: %v", info.FullMethod, err)\n    } else {\n        log.Printf("gRPC stream: %s completed", info.FullMethod)\n    }\n    return err\n}\n'})})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)("summary",{children:"Node.js Server Implementation"}),"\n",(0,t.jsx)(n.strong,{children:"Click to expand Node.js gRPC server code"})]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// server.js\nconst grpc = require('@grpc/grpc-js');\nconst protoLoader = require('@grpc/proto-loader');\nconst path = require('path');\n\n// Load proto file\nconst PROTO_PATH = path.join(__dirname, 'user.proto');\nconst packageDefinition = protoLoader.loadSync(PROTO_PATH, {\n  keepCase: true,\n  longs: String,\n  enums: String,\n  defaults: true,\n  oneofs: true\n});\n\nconst userProto = grpc.loadPackageDefinition(packageDefinition).user.v1;\n\n// In-memory user storage\nconst users = new Map();\n\n// User service implementation\nconst userService = {\n  createUser: (call, callback) => {\n    const request = call.request;\n    \n    // Validation\n    if (!request.email) {\n      return callback({\n        code: grpc.status.INVALID_ARGUMENT,\n        message: 'Email is required'\n      });\n    }\n\n    // Check if user already exists\n    for (const user of users.values()) {\n      if (user.email === request.email) {\n        return callback({\n          code: grpc.status.ALREADY_EXISTS,\n          message: `User with email ${request.email} already exists`\n        });\n      }\n    }\n\n    // Create user\n    const userId = `user_${Date.now()}`;\n    const user = {\n      id: userId,\n      email: request.email,\n      first_name: request.first_name,\n      last_name: request.last_name,\n      status: 'USER_STATUS_ACTIVE',\n      created_at: { seconds: Math.floor(Date.now() / 1000) },\n      updated_at: { seconds: Math.floor(Date.now() / 1000) },\n      address: request.address,\n      roles: ['user']\n    };\n\n    users.set(userId, user);\n\n    console.log(`Created user: ${user.id} (${user.email})`);\n\n    callback(null, {\n      user: user,\n      message: 'User created successfully'\n    });\n  },\n\n  getUser: (call, callback) => {\n    const userId = call.request.id;\n    \n    if (!userId) {\n      return callback({\n        code: grpc.status.INVALID_ARGUMENT,\n        message: 'User ID is required'\n      });\n    }\n\n    const user = users.get(userId);\n    if (!user) {\n      return callback({\n        code: grpc.status.NOT_FOUND,\n        message: `User with ID ${userId} not found`\n      });\n    }\n\n    callback(null, { user });\n  },\n\n  updateUser: (call, callback) => {\n    const request = call.request;\n    const user = users.get(request.id);\n\n    if (!user) {\n      return callback({\n        code: grpc.status.NOT_FOUND,\n        message: `User with ID ${request.id} not found`\n      });\n    }\n\n    // Update user fields\n    if (request.email) user.email = request.email;\n    if (request.first_name) user.first_name = request.first_name;\n    if (request.last_name) user.last_name = request.last_name;\n    if (request.address) user.address = request.address;\n    \n    user.updated_at = { seconds: Math.floor(Date.now() / 1000) };\n\n    callback(null, { user });\n  },\n\n  deleteUser: (call, callback) => {\n    const userId = call.request.id;\n    \n    if (!users.has(userId)) {\n      return callback({\n        code: grpc.status.NOT_FOUND,\n        message: `User with ID ${userId} not found`\n      });\n    }\n\n    users.delete(userId);\n    console.log(`Deleted user: ${userId}`);\n    \n    callback(null, {}); // Empty response\n  },\n\n  listUsers: (call, callback) => {\n    const request = call.request;\n    let pageSize = request.page_size || 10;\n    \n    if (pageSize > 100) pageSize = 100;\n\n    const allUsers = Array.from(users.values());\n    \n    // Simple filter implementation\n    let filteredUsers = allUsers;\n    if (request.filter === 'status=ACTIVE') {\n      filteredUsers = allUsers.filter(user => user.status === 'USER_STATUS_ACTIVE');\n    }\n\n    // Simple pagination\n    const startIndex = request.page_token ? parseInt(request.page_token) : 0;\n    const endIndex = Math.min(startIndex + pageSize, filteredUsers.length);\n    const pageUsers = filteredUsers.slice(startIndex, endIndex);\n\n    const nextPageToken = endIndex < filteredUsers.length ? endIndex.toString() : '';\n\n    callback(null, {\n      users: pageUsers,\n      next_page_token: nextPageToken,\n      total_count: filteredUsers.length\n    });\n  },\n\n  // Server streaming\n  getUserEvents: (call) => {\n    const userId = call.request.user_id;\n    \n    // Simulate streaming events\n    const events = [\n      {\n        event_id: 'evt_1',\n        user_id: userId,\n        event_type: 'EVENT_TYPE_CREATED',\n        timestamp: { seconds: Math.floor(Date.now() / 1000) },\n        data: JSON.stringify({ action: 'user_created' })\n      },\n      {\n        event_id: 'evt_2',\n        user_id: userId,\n        event_type: 'EVENT_TYPE_LOGIN',\n        timestamp: { seconds: Math.floor(Date.now() / 1000) },\n        data: JSON.stringify({ ip: '192.168.1.1', user_agent: 'Chrome' })\n      }\n    ];\n\n    let index = 0;\n    const interval = setInterval(() => {\n      if (index < events.length) {\n        call.write(events[index]);\n        index++;\n      } else {\n        clearInterval(interval);\n        call.end();\n      }\n    }, 1000);\n\n    call.on('cancelled', () => {\n      clearInterval(interval);\n      console.log('Client cancelled getUserEvents stream');\n    });\n  },\n\n  // Client streaming\n  batchCreateUsers: (call, callback) => {\n    const results = [];\n    let successCount = 0;\n    let failureCount = 0;\n\n    call.on('data', (request) => {\n      // Simulate user creation\n      try {\n        if (!request.email) {\n          throw new Error('Email is required');\n        }\n\n        const userId = `user_${Date.now()}_${Math.random()}`;\n        const user = {\n          id: userId,\n          email: request.email,\n          first_name: request.first_name,\n          last_name: request.last_name,\n          status: 'USER_STATUS_ACTIVE',\n          created_at: { seconds: Math.floor(Date.now() / 1000) },\n          updated_at: { seconds: Math.floor(Date.now() / 1000) },\n          address: request.address,\n          roles: ['user']\n        };\n\n        users.set(userId, user);\n        results.push({ user, message: 'User created successfully' });\n        successCount++;\n      } catch (error) {\n        results.push({ message: error.message });\n        failureCount++;\n      }\n    });\n\n    call.on('end', () => {\n      callback(null, {\n        results,\n        success_count: successCount,\n        failure_count: failureCount\n      });\n    });\n  },\n\n  // Bidirectional streaming\n  streamUserUpdates: (call) => {\n    call.on('data', (request) => {\n      const user = users.get(request.user_id);\n      \n      if (!user) {\n        call.write({\n          user_id: request.user_id,\n          success: false,\n          error_message: 'User not found'\n        });\n        return;\n      }\n\n      // Update field\n      switch (request.field_name) {\n        case 'first_name':\n          user.first_name = request.field_value;\n          break;\n        case 'last_name':\n          user.last_name = request.field_value;\n          break;\n        default:\n          call.write({\n            user_id: request.user_id,\n            success: false,\n            error_message: 'Invalid field name'\n          });\n          return;\n      }\n\n      user.updated_at = { seconds: Math.floor(Date.now() / 1000) };\n\n      call.write({\n        user_id: request.user_id,\n        success: true\n      });\n    });\n\n    call.on('end', () => {\n      call.end();\n    });\n  }\n};\n\n// Create and start server\nfunction main() {\n  const server = new grpc.Server();\n  \n  server.addService(userProto.UserService.service, userService);\n  \n  const address = '0.0.0.0:50051';\n  server.bindAsync(address, grpc.ServerCredentials.createInsecure(), (err, port) => {\n    if (err) {\n      console.error('Failed to bind server:', err);\n      return;\n    }\n    \n    console.log(`gRPC server listening on ${address}`);\n    server.start();\n  });\n}\n\nmain();\n"})})]}),"\n",(0,t.jsx)(n.h3,{id:"grpc-vs-rest-vs-graphql-comparison",children:"gRPC vs REST vs GraphQL Comparison"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature"}),(0,t.jsx)(n.th,{children:"REST"}),(0,t.jsx)(n.th,{children:"GraphQL"}),(0,t.jsx)(n.th,{children:"gRPC"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Protocol"})}),(0,t.jsx)(n.td,{children:"HTTP/1.1"}),(0,t.jsx)(n.td,{children:"HTTP/1.1"}),(0,t.jsx)(n.td,{children:"HTTP/2"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Data Format"})}),(0,t.jsx)(n.td,{children:"JSON/XML"}),(0,t.jsx)(n.td,{children:"JSON"}),(0,t.jsx)(n.td,{children:"Protocol Buffers"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Performance"})}),(0,t.jsx)(n.td,{children:"Good"}),(0,t.jsx)(n.td,{children:"Good"}),(0,t.jsx)(n.td,{children:"Excellent"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Streaming"})}),(0,t.jsx)(n.td,{children:"Limited"}),(0,t.jsx)(n.td,{children:"Subscriptions"}),(0,t.jsx)(n.td,{children:"Built-in (4 types)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Type Safety"})}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Schema-based"}),(0,t.jsx)(n.td,{children:"Strong (Proto)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Caching"})}),(0,t.jsx)(n.td,{children:"Excellent"}),(0,t.jsx)(n.td,{children:"Complex"}),(0,t.jsx)(n.td,{children:"Limited"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Browser Support"})}),(0,t.jsx)(n.td,{children:"Native"}),(0,t.jsx)(n.td,{children:"Native"}),(0,t.jsx)(n.td,{children:"Limited (grpc-web)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Learning Curve"})}),(0,t.jsx)(n.td,{children:"Easy"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"Steep"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Best For"})}),(0,t.jsx)(n.td,{children:"Public APIs"}),(0,t.jsx)(n.td,{children:"Complex queries"}),(0,t.jsx)(n.td,{children:"Internal services"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-grpc",children:"When to Use gRPC"}),"\n",(0,t.jsxs)(n.p,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Great for:"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Internal microservice communication"}),"\n",(0,t.jsx)(n.li,{children:"High-performance requirements"}),"\n",(0,t.jsx)(n.li,{children:"Real-time streaming data"}),"\n",(0,t.jsx)(n.li,{children:"Polyglot environments (multi-language)"}),"\n",(0,t.jsx)(n.li,{children:"Strong typing requirements"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["\u274c ",(0,t.jsx)(n.strong,{children:"Not ideal for:"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Public web APIs (limited browser support)"}),"\n",(0,t.jsx)(n.li,{children:"Simple CRUD operations"}),"\n",(0,t.jsx)(n.li,{children:"When HTTP caching is critical"}),"\n",(0,t.jsx)(n.li,{children:"Team unfamiliar with Protocol Buffers"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"graphql-schema-and-resolvers-examples",children:"GraphQL Schema and Resolvers Examples"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Schema Definition (GraphQL SDL):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"type User {\n  id: ID!\n  name: String!\n  email: String!\n  posts: [Post!]!\n  createdAt: String!\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n  author: User!\n  comments: [Comment!]!\n  publishedAt: String\n}\n\ntype Comment {\n  id: ID!\n  content: String!\n  author: User!\n  post: Post!\n  createdAt: String!\n}\n\ntype Query {\n  users(limit: Int, offset: Int): [User!]!\n  user(id: ID!): User\n  posts(authorId: ID, published: Boolean): [Post!]!\n  post(id: ID!): Post\n}\n\ntype Mutation {\n  createUser(input: CreateUserInput!): User!\n  updateUser(id: ID!, input: UpdateUserInput!): User!\n  createPost(input: CreatePostInput!): Post!\n  publishPost(id: ID!): Post!\n}\n\ninput CreateUserInput {\n  name: String!\n  email: String!\n}\n\ninput UpdateUserInput {\n  name: String\n  email: String\n}\n\ninput CreatePostInput {\n  title: String!\n  content: String!\n  authorId: ID!\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Resolver Implementation (Node.js):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const resolvers = {\n  Query: {\n    users: async (parent, { limit = 10, offset = 0 }) => {\n      return await userService.getUsers({ limit, offset });\n    },\n    \n    user: async (parent, { id }) => {\n      const user = await userService.getUserById(id);\n      if (!user) {\n        throw new Error(`User with id ${id} not found`);\n      }\n      return user;\n    },\n    \n    posts: async (parent, { authorId, published }) => {\n      return await postService.getPosts({ authorId, published });\n    }\n  },\n  \n  Mutation: {\n    createUser: async (parent, { input }) => {\n      try {\n        return await userService.createUser(input);\n      } catch (error) {\n        if (error.code === 'DUPLICATE_EMAIL') {\n          throw new Error('Email already exists');\n        }\n        throw error;\n      }\n    },\n    \n    createPost: async (parent, { input }, context) => {\n      // Check authentication\n      if (!context.user) {\n        throw new Error('Authentication required');\n      }\n      \n      // Check authorization\n      if (context.user.id !== input.authorId) {\n        throw new Error('You can only create posts for yourself');\n      }\n      \n      return await postService.createPost(input);\n    }\n  },\n  \n  // Nested field resolvers\n  User: {\n    posts: async (user, args, context, info) => {\n      // Check if posts are already loaded (to avoid N+1)\n      if (user.posts) {\n        return user.posts;\n      }\n      \n      // Use DataLoader to batch requests\n      return context.loaders.postsByAuthor.load(user.id);\n    }\n  },\n  \n  Post: {\n    author: async (post, args, context) => {\n      return context.loaders.userById.load(post.authorId);\n    },\n    \n    comments: async (post, args, context) => {\n      return context.loaders.commentsByPost.load(post.id);\n    }\n  }\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"DataLoader for N+1 Problem Prevention:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const DataLoader = require('dataloader');\n\n// Batch function for loading users\nconst batchUsers = async (userIds) => {\n  const users = await userService.getUsersByIds(userIds);\n  // Return users in the same order as requested IDs\n  return userIds.map(id => users.find(user => user.id === id));\n};\n\n// Batch function for loading posts by author\nconst batchPostsByAuthor = async (authorIds) => {\n  const posts = await postService.getPostsByAuthorIds(authorIds);\n  // Group posts by author ID\n  return authorIds.map(authorId => \n    posts.filter(post => post.authorId === authorId)\n  );\n};\n\n// Create loaders in context\nconst createLoaders = () => ({\n  userById: new DataLoader(batchUsers),\n  postsByAuthor: new DataLoader(batchPostsByAuthor),\n  commentsByPost: new DataLoader(batchCommentsByPost)\n});\n\n// Apollo Server setup\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  context: ({ req }) => {\n    return {\n      user: req.user, // from authentication middleware\n      loaders: createLoaders()\n    };\n  }\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Client Query Examples:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"# Fetch specific fields only\nquery GetUsers {\n  users(limit: 5) {\n    id\n    name\n    email\n    posts {\n      id\n      title\n      publishedAt\n    }\n  }\n}\n\n# Complex nested query\nquery GetUserWithRecentActivity($userId: ID!) {\n  user(id: $userId) {\n    id\n    name\n    email\n    posts(limit: 3) {\n      id\n      title\n      comments(limit: 2) {\n        id\n        content\n        author {\n          name\n        }\n      }\n    }\n  }\n}\n\n# Mutation with error handling\nmutation CreatePost($input: CreatePostInput!) {\n  createPost(input: $input) {\n    id\n    title\n    content\n    author {\n      name\n    }\n    createdAt\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"solving-the-n1-problem",children:"Solving the N+1 Problem"}),"\n",(0,t.jsxs)(n.p,{children:['A classic issue with REST is under-fetching, which often leads to the "N+1" query problem. Imagine fetching a list of authors (',(0,t.jsx)(n.code,{children:"1"})," query) and then fetching the books for each of those ",(0,t.jsx)(n.code,{children:"N"})," authors (",(0,t.jsx)(n.code,{children:"N"})," queries)."]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant Server (REST)\n    participant Database\n\n    Client->>Server (REST): GET /authors\n    Server (REST)->>Database: SELECT * FROM authors\n    Database--\x3e>Server (REST): N authors\n    Server (REST)--\x3e>Client: List of N authors\n\n    loop For Each Author\n        Client->>Server (REST): GET /authors/{id}/books\n        Server (REST)->>Database: SELECT * FROM books WHERE author_id = {id}\n        Database--\x3e>Server (REST): Books\n        Server (REST)--\x3e>Client: List of books\n    end\n    Note right of Client: Total N+1 queries"}),"\n",(0,t.jsx)(n.p,{children:"GraphQL solves this by fetching all the required information in a single, declarative query."}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant Server (GraphQL)\n    participant Database\n\n    Client->>Server (GraphQL): query { authors { name, books { title } } }\n    Server (GraphQL)->>Database: Executes optimized query (e.g., with a JOIN)\n    Database--\x3e>Server (GraphQL): Authors and their books\n    Server (GraphQL)--\x3e>Client: Single response with all data\n    Note right of Client: Total 1 query"}),"\n",(0,t.jsx)(n.admonition,{title:"Deep Dive: Resources",type:"tip",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://graphql.org/learn/",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"Introduction to GraphQL"})," (Official Site)"]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=ed8SzALpx1Q",children:["\u25b6\ufe0f ",(0,t.jsx)(n.strong,{children:"GraphQL Full Course"})," (YouTube)"]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://www.apollographql.com/",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"Apollo GraphQL Platform"})]})}),"\n"]})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"api-security-best-practices",children:"API Security Best Practices"}),"\n",(0,t.jsx)(n.p,{children:"Securing your APIs is critical. An insecure API can expose sensitive data and put your entire system at risk."}),"\n",(0,t.jsx)(n.h3,{id:"authentication--authorization",children:"Authentication & Authorization"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Authentication:"})," Verifying who a user is."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Authorization:"})," Determining what an authenticated user is allowed to do."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"OAuth 2.0"}),' is the industry-standard protocol for authorization. The "Authorization Code" flow is the most common and secure for web applications.']}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant ClientApp as Your Application\n    participant AuthServer as Authorization Server\n    participant ApiServer as Your API Server\n\n    User->>ClientApp: Log in\n    ClientApp->>AuthServer: Redirect user with client_id & scope\n    User->>AuthServer: Enters credentials\n    AuthServer--\x3e>ClientApp: Redirect with Authorization Code\n    ClientApp->>AuthServer: Exchange Authorization Code for Access Token\n    AuthServer--\x3e>ClientApp: Returns Access Token & Refresh Token\n    ClientApp->>ApiServer: Call API with Access Token\n    ApiServer->>AuthServer: Validate Access Token (optional, often via JWT signature)\n    ApiServer--\x3e>ClientApp: Return requested data"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"JSON Web Tokens (JWT)"})," are a common way to implement stateless authentication. The server creates a signed token containing user claims, and the client sends this token with each request. The server can verify the token's signature without needing to store session state."]}),"\n",(0,t.jsx)(n.h3,{id:"jwt-implementation-examples",children:"JWT Implementation Examples"}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"JWT Creation and Validation (Node.js)"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\n\nclass AuthService {\n    static async login(email, password) {\n        // 1. Validate user credentials\n        const user = await userService.getUserByEmail(email);\n        if (!user) {\n            throw new Error('Invalid credentials');\n        }\n        \n        const isValidPassword = await bcrypt.compare(password, user.hashedPassword);\n        if (!isValidPassword) {\n            throw new Error('Invalid credentials');\n        }\n        \n        // 2. Create JWT payload\n        const payload = {\n            userId: user.id,\n            email: user.email,\n            roles: user.roles,\n            iat: Math.floor(Date.now() / 1000), // Issued at\n            exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24) // Expires in 24 hours\n        };\n        \n        // 3. Sign the token\n        const accessToken = jwt.sign(payload, process.env.JWT_SECRET, {\n            algorithm: 'HS256'\n        });\n        \n        // 4. Create refresh token\n        const refreshToken = jwt.sign(\n            { userId: user.id, type: 'refresh' },\n            process.env.JWT_REFRESH_SECRET,\n            { expiresIn: '7d' }\n        );\n        \n        return {\n            accessToken,\n            refreshToken,\n            expiresIn: 86400, // 24 hours in seconds\n            user: {\n                id: user.id,\n                email: user.email,\n                name: user.name\n            }\n        };\n    }\n    \n    static async verifyToken(token) {\n        try {\n            const decoded = jwt.verify(token, process.env.JWT_SECRET);\n            return decoded;\n        } catch (error) {\n            if (error.name === 'TokenExpiredError') {\n                throw new Error('Token expired');\n            }\n            throw new Error('Invalid token');\n        }\n    }\n    \n    static async refreshAccessToken(refreshToken) {\n        try {\n            const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);\n            \n            if (decoded.type !== 'refresh') {\n                throw new Error('Invalid refresh token');\n            }\n            \n            const user = await userService.getUserById(decoded.userId);\n            if (!user) {\n                throw new Error('User not found');\n            }\n            \n            // Generate new access token\n            return this.generateAccessToken(user);\n        } catch (error) {\n            throw new Error('Invalid refresh token');\n        }\n    }\n}\n\n// Authentication middleware\nconst authenticateToken = async (req, res, next) => {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n    \n    if (!token) {\n        return res.status(401).json({ error: 'Access token required' });\n    }\n    \n    try {\n        const decoded = await AuthService.verifyToken(token);\n        req.user = decoded;\n        next();\n    } catch (error) {\n        return res.status(403).json({ error: error.message });\n    }\n};\n\n// Role-based authorization middleware\nconst requireRoles = (...roles) => {\n    return (req, res, next) => {\n        if (!req.user) {\n            return res.status(401).json({ error: 'Authentication required' });\n        }\n        \n        const hasRequiredRole = roles.some(role => req.user.roles.includes(role));\n        if (!hasRequiredRole) {\n            return res.status(403).json({ error: 'Insufficient permissions' });\n        }\n        \n        next();\n    };\n};\n\n// Usage in routes\napp.post('/api/auth/login', async (req, res) => {\n    try {\n        const { email, password } = req.body;\n        const authResult = await AuthService.login(email, password);\n        res.json(authResult);\n    } catch (error) {\n        res.status(401).json({ error: error.message });\n    }\n});\n\napp.get('/api/profile', authenticateToken, (req, res) => {\n    res.json({ user: req.user });\n});\n\napp.delete('/api/users/:id', authenticateToken, requireRoles('admin'), (req, res) => {\n    // Only admins can delete users\n    userService.deleteUser(req.params.id);\n    res.status(204).send();\n});\n"})})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"C# JWT Implementation"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Microsoft.IdentityModel.Tokens;\nusing System.IdentityModel.Tokens.Jwt;\nusing System.Security.Claims;\n\npublic class JwtService\n{\n    private readonly IConfiguration _configuration;\n    \n    public JwtService(IConfiguration configuration)\n    {\n        _configuration = configuration;\n    }\n    \n    public string GenerateToken(User user)\n    {\n        var claims = new List<Claim>\n        {\n            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),\n            new Claim(ClaimTypes.Email, user.Email),\n            new Claim(ClaimTypes.Name, user.Name)\n        };\n        \n        // Add role claims\n        foreach (var role in user.Roles)\n        {\n            claims.Add(new Claim(ClaimTypes.Role, role));\n        }\n        \n        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["Jwt:Secret"]));\n        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);\n        \n        var token = new JwtSecurityToken(\n            issuer: _configuration["Jwt:Issuer"],\n            audience: _configuration["Jwt:Audience"],\n            claims: claims,\n            expires: DateTime.UtcNow.AddHours(24),\n            signingCredentials: credentials\n        );\n        \n        return new JwtSecurityTokenHandler().WriteToken(token);\n    }\n    \n    public ClaimsPrincipal ValidateToken(string token)\n    {\n        var tokenHandler = new JwtSecurityTokenHandler();\n        var key = Encoding.UTF8.GetBytes(_configuration["Jwt:Secret"]);\n        \n        var validationParameters = new TokenValidationParameters\n        {\n            ValidateIssuerSigningKey = true,\n            IssuerSigningKey = new SymmetricSecurityKey(key),\n            ValidateIssuer = true,\n            ValidIssuer = _configuration["Jwt:Issuer"],\n            ValidateAudience = true,\n            ValidAudience = _configuration["Jwt:Audience"],\n            ValidateLifetime = true,\n            ClockSkew = TimeSpan.Zero\n        };\n        \n        var principal = tokenHandler.ValidateToken(token, validationParameters, out _);\n        return principal;\n    }\n}\n\n// Usage in ASP.NET Core controller\n[ApiController]\n[Route("api/[controller]")]\npublic class AuthController : ControllerBase\n{\n    private readonly JwtService _jwtService;\n    private readonly UserService _userService;\n    \n    [HttpPost("login")]\n    public async Task<IActionResult> Login([FromBody] LoginRequest request)\n    {\n        var user = await _userService.ValidateCredentialsAsync(request.Email, request.Password);\n        if (user == null)\n        {\n            return Unauthorized(new { Error = "Invalid credentials" });\n        }\n        \n        var token = _jwtService.GenerateToken(user);\n        \n        return Ok(new\n        {\n            AccessToken = token,\n            ExpiresIn = 86400,\n            User = new\n            {\n                Id = user.Id,\n                Email = user.Email,\n                Name = user.Name\n            }\n        });\n    }\n}\n\n// Authorization attribute usage\n[Authorize(Roles = "Admin")]\n[HttpDelete("{id}")]\npublic async Task<IActionResult> DeleteUser(int id)\n{\n    await _userService.DeleteUserAsync(id);\n    return NoContent();\n}\n'})})]}),"\n",(0,t.jsx)(n.admonition,{title:"Deep Dive: Resources",type:"tip",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://www.oauth.com/",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"OAuth 2.0 Simplified"})]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://jwt.io/introduction",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"JWT.io Introduction"})]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://cheatsheetseries.owasp.org/API_Security_Cheat_Sheet.html",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"API Security Checklist"})," (OWASP)"]})}),"\n"]})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"testing-strategies-for-apis",children:"Testing Strategies for APIs"}),"\n",(0,t.jsx)(n.p,{children:"A senior developer must ensure code quality through comprehensive testing. APIs require special attention due to their role as contracts between systems."}),"\n",(0,t.jsx)(n.h3,{id:"testing-pyramid",children:"Testing Pyramid"}),"\n",(0,t.jsx)(n.mermaid,{value:'graph TD\n    subgraph "Testing Pyramid"\n        A[End-to-End Tests <br/> Few, Slow, Expensive];\n        B[Integration Tests <br/> Some, Medium Speed];\n        C[Unit Tests <br/> Many, Fast, Cheap];\n    end\n    C --\x3e B;\n    B --\x3e A;'}),"\n",(0,t.jsx)(n.h3,{id:"types-of-api-testing",children:"Types of API Testing"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unit Tests:"})," Test individual functions and methods in isolation. Mock external dependencies."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Integration Tests:"})," Test how your code interacts with external systems (databases, other services)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Contract Tests:"})," Ensure APIs meet their documented contracts. Tools like ",(0,t.jsx)(n.strong,{children:"Pact"})," enable consumer-driven contract testing."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"End-to-End Tests:"})," Test the complete user workflow through the system. Expensive but catch integration issues."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"testing-best-practices",children:"Testing Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test-Driven Development (TDD):"})," Write tests before implementation. Red \u2192 Green \u2192 Refactor cycle."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arrange-Act-Assert (AAA) Pattern:"})," Structure tests clearly:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arrange:"})," Set up test data and mocks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Act:"})," Execute the code under test"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Assert:"})," Verify the results"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"comprehensive-api-testing-examples",children:"Comprehensive API Testing Examples"}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Unit Testing with Mocking (Jest/Node.js)"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// userController.test.js\nconst request = require('supertest');\nconst app = require('../app');\nconst userService = require('../services/userService');\n\n// Mock the service layer\njest.mock('../services/userService');\n\ndescribe('User API Endpoints', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  describe('POST /api/users', () => {\n    it('should create a new user', async () => {\n      // Arrange\n      const userData = { name: 'John Doe', email: 'john@example.com' };\n      const mockUser = { id: 1, ...userData, createdAt: '2023-01-01T00:00:00Z' };\n      userService.createUser.mockResolvedValue(mockUser);\n\n      // Act\n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect('Content-Type', /json/);\n\n      // Assert\n      expect(response.status).toBe(201);\n      expect(response.body.data).toEqual(mockUser);\n      expect(response.body.links.self).toBe(`/api/users/${mockUser.id}`);\n      expect(userService.createUser).toHaveBeenCalledWith(userData);\n    });\n    \n    it('should return 400 for invalid data', async () => {\n      // Arrange\n      const invalidData = { name: '', email: 'invalid-email' };\n      \n      // Act\n      const response = await request(app)\n        .post('/api/users')\n        .send(invalidData);\n      \n      // Assert\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('Validation failed');\n      expect(response.body.details).toHaveProperty('name');\n      expect(response.body.details).toHaveProperty('email');\n      expect(userService.createUser).not.toHaveBeenCalled();\n    });\n    \n    it('should return 409 for duplicate email', async () => {\n      // Arrange\n      const userData = { name: 'John Doe', email: 'existing@example.com' };\n      const duplicateError = new Error('Email already exists');\n      duplicateError.code = 'DUPLICATE_EMAIL';\n      userService.createUser.mockRejectedValue(duplicateError);\n      \n      // Act\n      const response = await request(app)\n        .post('/api/users')\n        .send(userData);\n      \n      // Assert\n      expect(response.status).toBe(409);\n      expect(response.body.error).toBe('Email already exists');\n    });\n  });\n  \n  describe('GET /api/users/:id', () => {\n    it('should return user by id', async () => {\n      // Arrange\n      const mockUser = { id: 1, name: 'John Doe', email: 'john@example.com' };\n      userService.getUserById.mockResolvedValue(mockUser);\n      \n      // Act\n      const response = await request(app)\n        .get('/api/users/1');\n      \n      // Assert\n      expect(response.status).toBe(200);\n      expect(response.body.data).toEqual(mockUser);\n    });\n    \n    it('should return 404 for non-existent user', async () => {\n      // Arrange\n      userService.getUserById.mockResolvedValue(null);\n      \n      // Act\n      const response = await request(app)\n        .get('/api/users/999');\n      \n      // Assert\n      expect(response.status).toBe(404);\n      expect(response.body.error).toBe('User not found');\n    });\n  });\n});\n"})})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Integration Testing (Database + API)"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// integration/userApi.test.js\nconst request = require('supertest');\nconst app = require('../app');\nconst { setupTestDB, teardownTestDB } = require('./helpers/dbHelper');\n\ndescribe('User API Integration Tests', () => {\n  beforeAll(async () => {\n    await setupTestDB();\n  });\n  \n  afterAll(async () => {\n    await teardownTestDB();\n  });\n  \n  it('should create and retrieve a user', async () => {\n    // Create user\n    const userData = { name: 'Integration Test User', email: 'integration@test.com' };\n    const createResponse = await request(app)\n      .post('/api/users')\n      .send(userData)\n      .expect(201);\n    \n    const createdUser = createResponse.body.data;\n    expect(createdUser).toHaveProperty('id');\n    expect(createdUser.name).toBe(userData.name);\n    \n    // Retrieve user\n    const getResponse = await request(app)\n      .get(`/api/users/${createdUser.id}`)\n      .expect(200);\n    \n    expect(getResponse.body.data).toEqual(createdUser);\n  });\n});\n"})})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Contract Testing with Pact (Consumer Side)"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// userApiPact.test.js\nconst { Pact } = require('@pact-foundation/pact');\nconst axios = require('axios');\n\nconst provider = new Pact({\n  consumer: 'UserWebApp',\n  provider: 'UserAPI',\n  port: 3001,\n  log: './pact/logs/pact.log',\n  dir: './pact/pacts',\n  logLevel: 'INFO'\n});\n\ndescribe('User API Contract Tests', () => {\n  beforeAll(() => provider.setup());\n  afterEach(() => provider.verify());\n  afterAll(() => provider.finalize());\n  \n  it('should get user by id', async () => {\n    // Arrange - Define expected interaction\n    await provider.addInteraction({\n      state: 'user with id 1 exists',\n      uponReceiving: 'a request for user 1',\n      withRequest: {\n        method: 'GET',\n        path: '/api/users/1',\n        headers: {\n          'Accept': 'application/json'\n        }\n      },\n      willRespondWith: {\n        status: 200,\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: {\n          data: {\n            id: 1,\n            name: 'John Doe',\n            email: 'john@example.com'\n          }\n        }\n      }\n    });\n    \n    // Act\n    const response = await axios.get('http://localhost:3001/api/users/1', {\n      headers: { 'Accept': 'application/json' }\n    });\n    \n    // Assert\n    expect(response.status).toBe(200);\n    expect(response.data.data.id).toBe(1);\n    expect(response.data.data.name).toBe('John Doe');\n  });\n});\n"})})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"End-to-End API Testing (with authentication)"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// e2e/userFlow.test.js\nconst request = require('supertest');\nconst app = require('../app');\n\ndescribe('User Management E2E Flow', () => {\n  let authToken;\n  let createdUserId;\n  \n  it('should authenticate admin user', async () => {\n    const response = await request(app)\n      .post('/api/auth/login')\n      .send({\n        email: 'admin@test.com',\n        password: 'adminpassword'\n      })\n      .expect(200);\n    \n    authToken = response.body.accessToken;\n    expect(authToken).toBeDefined();\n  });\n  \n  it('should create, read, update, and delete user', async () => {\n    // Create\n    const createResponse = await request(app)\n      .post('/api/users')\n      .set('Authorization', `Bearer ${authToken}`)\n      .send({\n        name: 'E2E Test User',\n        email: 'e2e@test.com'\n      })\n      .expect(201);\n    \n    createdUserId = createResponse.body.data.id;\n    \n    // Read\n    await request(app)\n      .get(`/api/users/${createdUserId}`)\n      .set('Authorization', `Bearer ${authToken}`)\n      .expect(200);\n    \n    // Update\n    await request(app)\n      .patch(`/api/users/${createdUserId}`)\n      .set('Authorization', `Bearer ${authToken}`)\n      .send({ name: 'Updated Name' })\n      .expect(200);\n    \n    // Delete\n    await request(app)\n      .delete(`/api/users/${createdUserId}`)\n      .set('Authorization', `Bearer ${authToken}`)\n      .expect(204);\n    \n    // Verify deletion\n    await request(app)\n      .get(`/api/users/${createdUserId}`)\n      .set('Authorization', `Bearer ${authToken}`)\n      .expect(404);\n  });\n});\n"})})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Load Testing with Artillery"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"# artillery-config.yml\nconfig:\n  target: 'http://localhost:3000'\n  phases:\n    - duration: 60\n      arrivalRate: 10\n    - duration: 120\n      arrivalRate: 50\n  defaults:\n    headers:\n      Content-Type: 'application/json'\n\nscenarios:\n  - name: 'Create and retrieve users'\n    weight: 70\n    flow:\n      - post:\n          url: '/api/users'\n          json:\n            name: 'Load Test User {{ $randomString() }}'\n            email: 'load{{ $randomInt(1, 10000) }}@test.com'\n          capture:\n            - json: '$.data.id'\n              as: 'userId'\n      - get:\n          url: '/api/users/{{ userId }}'\n  \n  - name: 'Get all users'\n    weight: 30\n    flow:\n      - get:\n          url: '/api/users?limit=20'\n"})})]}),"\n",(0,t.jsx)(n.h3,{id:"api-documentation--testing-tools",children:"API Documentation & Testing Tools"}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"OpenAPI/Swagger Documentation"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"# openapi.yml\nopenapi: 3.0.3\ninfo:\n  title: User Management API\n  description: A comprehensive API for managing users\n  version: 1.0.0\n  contact:\n    name: API Support\n    email: support@example.com\n\nservers:\n  - url: https://api.example.com/v1\n    description: Production server\n  - url: https://staging-api.example.com/v1\n    description: Staging server\n\npaths:\n  /users:\n    get:\n      summary: Get all users\n      description: Retrieve a paginated list of users\n      parameters:\n        - name: page\n          in: query\n          schema:\n            type: integer\n            default: 1\n            minimum: 1\n        - name: limit\n          in: query\n          schema:\n            type: integer\n            default: 10\n            minimum: 1\n            maximum: 100\n        - name: search\n          in: query\n          schema:\n            type: string\n          description: Search users by name or email\n      responses:\n        '200':\n          description: Successful response\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  data:\n                    type: array\n                    items:\n                      $ref: '#/components/schemas/User'\n                  pagination:\n                    $ref: '#/components/schemas/Pagination'\n    \n    post:\n      summary: Create a new user\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/CreateUserRequest'\n      responses:\n        '201':\n          description: User created successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  data:\n                    $ref: '#/components/schemas/User'\n        '400':\n          $ref: '#/components/responses/ValidationError'\n        '409':\n          $ref: '#/components/responses/ConflictError'\n\ncomponents:\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: integer\n          example: 123\n        name:\n          type: string\n          example: \"John Doe\"\n        email:\n          type: string\n          format: email\n          example: \"john@example.com\"\n        createdAt:\n          type: string\n          format: date-time\n          example: \"2023-01-01T00:00:00Z\"\n    \n    CreateUserRequest:\n      type: object\n      required:\n        - name\n        - email\n      properties:\n        name:\n          type: string\n          minLength: 1\n          maxLength: 100\n        email:\n          type: string\n          format: email\n  \n  responses:\n    ValidationError:\n      description: Validation error\n      content:\n        application/json:\n          schema:\n            type: object\n            properties:\n              error:\n                type: string\n                example: \"Validation failed\"\n              details:\n                type: object\n\n  securitySchemes:\n    bearerAuth:\n      type: http\n      scheme: bearer\n      bearerFormat: JWT\n\nsecurity:\n  - bearerAuth: []\n"})})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Newman (Postman CLI) Configuration"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "info": {\n    "name": "User API Test Suite",\n    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"\n  },\n  "item": [\n    {\n      "name": "Authentication",\n      "item": [\n        {\n          "name": "Login",\n          "event": [\n            {\n              "listen": "test",\n              "script": {\n                "exec": [\n                  "pm.test(\'Status code is 200\', () => {",\n                  "    pm.response.to.have.status(200);",\n                  "});",\n                  "",\n                  "pm.test(\'Response has access token\', () => {",\n                  "    const responseJson = pm.response.json();",\n                  "    pm.expect(responseJson).to.have.property(\'accessToken\');",\n                  "    pm.environment.set(\'authToken\', responseJson.accessToken);",\n                  "});"\n                ]\n              }\n            }\n          ],\n          "request": {\n            "method": "POST",\n            "header": [],\n            "body": {\n              "mode": "raw",\n              "raw": "{\\n  \\"email\\": \\"{{userEmail}}\\",\\n  \\"password\\": \\"{{userPassword}}\\"\\n}",\n              "options": {\n                "raw": {\n                  "language": "json"\n                }\n              }\n            },\n            "url": {\n              "raw": "{{baseUrl}}/auth/login",\n              "host": ["{{baseUrl}}"],\n              "path": ["auth", "login"]\n            }\n          }\n        }\n      ]\n    }\n  ],\n  "variable": [\n    {\n      "key": "baseUrl",\n      "value": "https://api.example.com/v1"\n    }\n  ]\n}\n'})})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Running API Tests in CI/CD"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Install Newman globally\nnpm install -g newman\n\n# Run Postman collection with environment\nnewman run user-api-tests.json \\\n  --environment production.json \\\n  --reporters cli,json \\\n  --reporter-json-export results.json\n\n# Run with data file for multiple test scenarios\nnewman run user-api-tests.json \\\n  --data test-data.csv \\\n  --iteration-count 10\n"})})]}),"\n",(0,t.jsx)(n.admonition,{title:"Deep Dive: Resources",type:"tip",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://martinfowler.com/articles/practical-test-pyramid.html",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"The Practical Test Pyramid"})," by Martin Fowler"]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=QCif_-r8eK4",children:["\u25b6\ufe0f ",(0,t.jsx)(n.strong,{children:"Test-Driven Development"})," (Video)"]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://docs.pact.io/",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"Contract Testing with Pact"})]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://assertible.com/blog/13-things-you-should-do-to-build-better-restful-web-apis",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"API Testing Best Practices"})]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://swagger.io/specification/",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"OpenAPI Specification"})]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://learning.postman.com/docs/running-collections/using-newman-cli/command-line-integration-with-newman/",children:["\ud83d\udee0\ufe0f ",(0,t.jsx)(n.strong,{children:"Newman Documentation"})]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://www.apollographql.com/docs/apollo-server/testing/testing/",children:["\ud83d\udcc4 ",(0,t.jsx)(n.strong,{children:"GraphQL Testing Guide"})]})}),"\n"]})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);