"use strict";(self.webpackChunkroadmap=self.webpackChunkroadmap||[]).push([[249],{6449:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"03-system-architecture","title":"System Architecture & Design","description":"System architecture is the high-level structure of a software system. For a senior engineer, making sound architectural decisions is paramount, as these choices have long-lasting effects on scalability, maintainability, and team productivity. This section covers the key architectural styles and patterns that define modern backend systems.","source":"@site/docs/03-system-architecture.mdx","sourceDirName":".","slug":"/system-architecture","permalink":"/roadmap/docs/system-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/alishahidi/roadmap/tree/main/docs/03-system-architecture.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"03-system-architecture","slug":"/system-architecture","sidebar_position":3,"title":"System Architecture & Design"},"sidebar":"roadmapSidebar","previous":{"title":"API Design & Development","permalink":"/roadmap/docs/api-design"},"next":{"title":"Data & Persistence","permalink":"/roadmap/docs/data-and-persistence"}}');var r=n(4848),i=n(8453);const a={id:"03-system-architecture",slug:"/system-architecture",sidebar_position:3,title:"System Architecture & Design"},o=void 0,c={},l=[{value:"Architectural Styles",id:"architectural-styles",level:2},{value:"Domain-Driven Design (DDD)",id:"domain-driven-design-ddd",level:2},{value:"Advanced Architectural Patterns",id:"advanced-architectural-patterns",level:2},{value:"Patterns for In-Service Design",id:"patterns-for-in-service-design",level:2},{value:"Essential Design Patterns for Senior Developers",id:"essential-design-patterns-for-senior-developers",level:2},{value:"Creational Patterns",id:"creational-patterns",level:3},{value:"Structural Patterns",id:"structural-patterns",level:3},{value:"Behavioral Patterns",id:"behavioral-patterns",level:3},{value:"Enterprise Patterns",id:"enterprise-patterns",level:3}];function d(e){const s={a:"a",admonition:"admonition",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.p,{children:"System architecture is the high-level structure of a software system. For a senior engineer, making sound architectural decisions is paramount, as these choices have long-lasting effects on scalability, maintainability, and team productivity. This section covers the key architectural styles and patterns that define modern backend systems."}),"\n",(0,r.jsx)(s.h2,{id:"architectural-styles",children:"Architectural Styles"}),"\n",(0,r.jsx)(s.p,{children:'The architectural style is the foundational choice that dictates how the system will be organized. There is no "best" style; the choice is a trade-off based on team size, business requirements, and scalability needs.'}),"\n",(0,r.jsx)(s.mermaid,{value:"graph TD\r\n    subgraph Monolith\r\n        direction LR\r\n        A[API] --\x3e B[Business Logic];\r\n        B --\x3e C[Data Access];\r\n    end\r\n\r\n    subgraph Microservices\r\n        direction LR\r\n        D[API Gateway] --\x3e E[Service A];\r\n        D --\x3e F[Service B];\r\n        D --\x3e G[Service C];\r\n    end\r\n\r\n    subgraph Event-Driven\r\n        direction LR\r\n        H[Producer] -- Event --\x3e I(Message Broker);\r\n        I -- Event --\x3e J[Consumer 1];\r\n        I -- Event --\x3e K[Consumer 2];\r\n    end"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Monolithic Architecture:"}),' A single, unified codebase. It\'s simple to start with but can become a "big ball of mud" if not carefully managed.']}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Microservices Architecture:"})," Breaks the system into small, independent services. This promotes team autonomy and technological diversity but introduces significant operational complexity."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Event-Driven Architecture (EDA):"})," A paradigm where components communicate asynchronously via events. This promotes loose coupling and resilience, making it a natural fit for microservices."]}),"\n"]}),"\n",(0,r.jsx)(s.admonition,{title:"Deep Dive: Resources",type:"tip",children:(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://martinfowler.com/articles/microservices.html",children:["\ud83d\udcc4 ",(0,r.jsx)(s.strong,{children:"Monolith vs Microservices"})," by Martin Fowler"]})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://www.youtube.com/watch?v=k8Ssh3-aE-c",children:["\u25b6\ufe0f ",(0,r.jsx)(s.strong,{children:"The Power of Event-Driven Architecture"})," (Video by Gregor Hohpe)"]})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://aws.amazon.com/event-driven-architecture/",children:["\ud83d\udcc4 ",(0,r.jsx)(s.strong,{children:"What is Event-Driven Architecture?"})," (AWS)"]})}),"\n"]})}),"\n",(0,r.jsx)(s.p,{children:":::"}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"domain-driven-design-ddd",children:"Domain-Driven Design (DDD)"}),"\n",(0,r.jsxs)(s.p,{children:["DDD is an approach to software development for complex business domains. It aligns the software model with the business model by establishing a ",(0,r.jsx)(s.strong,{children:"Ubiquitous Language"}),"\u2014a shared vocabulary between developers and domain experts."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Strategic DDD:"}),' The "macro" level. It\'s about decomposing the system into ',(0,r.jsx)(s.strong,{children:"Bounded Contexts"}),", which are logical boundaries for your domain models. ",(0,r.jsx)(s.strong,{children:"Context Mapping"})," is used to define the relationships between these contexts (e.g., via an ",(0,r.jsx)(s.strong,{children:"Anticorruption Layer"}),")."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Tactical DDD:"}),' The "micro" level. It provides a rich set of patterns for designing the model within a Bounded Context, including ',(0,r.jsx)(s.strong,{children:"Aggregates"}),", ",(0,r.jsx)(s.strong,{children:"Entities"}),", and ",(0,r.jsx)(s.strong,{children:"Value Objects"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.admonition,{title:"Deep Dive: Resources",type:"tip",children:(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://martinfowler.com/tags/domain%20driven%20design.html",children:["\ud83d\udcc4 ",(0,r.jsx)(s.strong,{children:"Domain-Driven Design"})," by Martin Fowler"]})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://www.youtube.com/watch?v=g_h6d6j1qIs",children:["\u25b6\ufe0f ",(0,r.jsx)(s.strong,{children:"What is DDD?"})," (Video by Eric Evans)"]})}),"\n"]})}),"\n",(0,r.jsx)(s.p,{children:":::"}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"advanced-architectural-patterns",children:"Advanced Architectural Patterns"}),"\n",(0,r.jsx)(s.p,{children:"These patterns solve specific, recurring problems in distributed systems."}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"CQRS (Command Query Responsibility Segregation):"})," Separates the models for reading data (Queries) and writing data (Commands). This is powerful because read and write workloads often have very different performance and consistency requirements. You can scale your read database independently of your write database."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Event Sourcing:"})," Instead of storing the current state of your data, you store a full, immutable sequence of the events that have happened to it. This provides a perfect audit log and allows you to derive the current state or any past state by replaying events. It's a natural fit for the command side of a CQRS system."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"SAGA Pattern:"})," Manages data consistency across microservices without using distributed transactions. A saga is a sequence of local transactions. If one transaction fails, the saga executes compensating transactions to undo the preceding work. This is essential for maintaining data integrity in a distributed environment."]}),"\n"]}),"\n",(0,r.jsx)(s.admonition,{title:"Deep Dive: Resources",type:"tip",children:(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://martinfowler.com/bliki/CQRS.html",children:["\ud83d\udcc4 ",(0,r.jsx)(s.strong,{children:"CQRS"})," by Martin Fowler"]})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://www.youtube.com/watch?v=JHGkaShoyNs",children:["\u25b6\ufe0f ",(0,r.jsx)(s.strong,{children:"Exploring CQRS and Event Sourcing"})," (Video by Greg Young)"]})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://microservices.io/patterns/data/saga.html",children:["\ud83d\udcc4 ",(0,r.jsx)(s.strong,{children:"Pattern: Saga"})," by Chris Richardson"]})}),"\n"]})}),"\n",(0,r.jsx)(s.p,{children:":::"}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"patterns-for-in-service-design",children:"Patterns for In-Service Design"}),"\n",(0,r.jsxs)(s.p,{children:["These patterns focus on how to structure the code ",(0,r.jsx)(s.em,{children:"within"})," a single service."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Clean Architecture:"})," Organizes the system in concentric layers, with a strict ",(0,r.jsx)(s.strong,{children:"Dependency Rule"}),": all dependencies must point inwards. This isolates your core business logic (Entities and Use Cases) from external concerns like databases, frameworks, and the UI."]}),"\n"]}),"\n",(0,r.jsx)(s.mermaid,{value:'graph TD\r\n    subgraph Layers\r\n        D["Frameworks & Drivers <br/> e.g., Web, UI, DB"];\r\n        C["Interface Adapters <br/> e.g., Controllers, Presenters"];\r\n        B["Use Cases <br/> Application-specific business rules"];\r\n        A["Entities <br/> Enterprise-wide business rules"];\r\n    end\r\n    D -- "depends on" --\x3e C;\r\n    C -- "depends on" --\x3e B;\r\n    B -- "depends on" --\x3e A;'}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Hexagonal Architecture (Ports & Adapters):"}),' Similar to Clean Architecture, it isolates the core application logic from external dependencies. The core logic defines "ports" (interfaces), and external tools are implemented as "adapters" that plug into these ports.']}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Mediator Pattern:"}),' A behavioral pattern that reduces coupling between components by having them communicate indirectly through a central "mediator" object. This is useful for decoupling command handlers from the business logic they orchestrate within a service.']}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"essential-design-patterns-for-senior-developers",children:"Essential Design Patterns for Senior Developers"}),"\n",(0,r.jsxs)(s.p,{children:["These are the fundamental ",(0,r.jsx)(s.strong,{children:"Gang of Four (GoF)"})," and ",(0,r.jsx)(s.strong,{children:"Enterprise Patterns"})," that every senior backend developer should master. They provide proven solutions to recurring design problems."]}),"\n",(0,r.jsx)(s.h3,{id:"creational-patterns",children:"Creational Patterns"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Factory Pattern:"})," Encapsulates object creation logic. Instead of calling constructors directly, you use a factory method to create objects. This is especially useful when the exact type of object depends on runtime conditions."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Builder Pattern:"})," Constructs complex objects step by step. Perfect for creating objects with many optional parameters (avoiding telescoping constructor anti-pattern)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Singleton Pattern:"})," Ensures a class has only one instance and provides global access to it. Use sparingly\u2014often dependency injection is a better alternative."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"structural-patterns",children:"Structural Patterns"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Adapter Pattern:"})," Allows incompatible interfaces to work together. Essential when integrating with third-party libraries or legacy systems."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Decorator Pattern:"})," Adds behavior to objects dynamically without altering their structure. Common in middleware chains and aspect-oriented programming."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Facade Pattern:"})," Provides a simplified interface to a complex subsystem. Reduces coupling between clients and complex subsystems."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"behavioral-patterns",children:"Behavioral Patterns"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Observer Pattern:"})," Defines a one-to-many dependency between objects. When one object changes state, all dependents are notified. Foundation of event-driven architectures."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Strategy Pattern:"})," Encapsulates algorithms and makes them interchangeable. Perfect for implementing different business rules or algorithms at runtime."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Command Pattern:"})," Encapsulates a request as an object, allowing you to parameterize clients with different requests, queue operations, and support undo operations."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Template Method Pattern:"})," Defines the skeleton of an algorithm in a base class, letting subclasses override specific steps without changing the algorithm's structure."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"enterprise-patterns",children:"Enterprise Patterns"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Repository Pattern:"})," Encapsulates data access logic and provides a more object-oriented view of the persistence layer. Essential for clean architecture and testability."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Unit of Work Pattern:"})," Maintains a list of objects affected by a business transaction and coordinates writing out changes and resolving concurrency problems."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Specification Pattern:"})," Encapsulates business rules in a reusable way. Allows combining business rules using logical operators (AND, OR, NOT)."]}),"\n"]}),"\n",(0,r.jsx)(s.mermaid,{value:'graph TD\r\n    subgraph "Creational Patterns"\r\n        A[Factory] --\x3e A1[Creates objects without specifying exact class];\r\n        B[Builder] --\x3e B1[Constructs complex objects step by step];\r\n        C[Singleton] --\x3e C1[Ensures single instance];\r\n    end\r\n    \r\n    subgraph "Structural Patterns"\r\n        D[Adapter] --\x3e D1[Makes incompatible interfaces compatible];\r\n        E[Decorator] --\x3e E1[Adds behavior dynamically];\r\n        F[Facade] --\x3e F1[Simplifies complex subsystem];\r\n    end\r\n    \r\n    subgraph "Behavioral Patterns"\r\n        G[Observer] --\x3e G1[Notifies multiple objects of changes];\r\n        H[Strategy] --\x3e H1[Encapsulates interchangeable algorithms];\r\n        I[Command] --\x3e I1[Encapsulates requests as objects];\r\n    end'}),"\n",(0,r.jsx)(s.admonition,{title:"Deep Dive: Resources",type:"tip",children:(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612",children:["\ud83d\udcc4 ",(0,r.jsx)(s.strong,{children:"Design Patterns: Elements of Reusable Object-Oriented Software"})," (Gang of Four Book)"]})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://martinfowler.com/eaaCatalog/",children:["\ud83d\udcc4 ",(0,r.jsx)(s.strong,{children:"Patterns of Enterprise Application Architecture"})," by Martin Fowler"]})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://www.youtube.com/watch?v=v9ejT8FO-7I",children:["\u25b6\ufe0f ",(0,r.jsx)(s.strong,{children:"Design Patterns in Plain English"})," (Video Series)"]})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://refactoring.guru/design-patterns",children:["\ud83d\udcc4 ",(0,r.jsx)(s.strong,{children:"Refactoring.Guru Design Patterns"})]})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsxs)(s.a,{href:"https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design",children:["\ud83d\udcc4 ",(0,r.jsx)(s.strong,{children:"Repository Pattern in C#"})]})}),"\n"]})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);